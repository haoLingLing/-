### 获取二进制位是0 还是1
思路:
做与运算 例如做判断x的第五位的二进制是1还是0，可以与1<<4 做与运算，然后将结果>>4  判断最终的结果是1 还是0 ，如果结果为0 ，则第五位为0 否则为1 
```js
const judje0_1=(x,y)=>{
  const result = x& 1<<(y-1) >>(y-1) ===0?'0':'1'
  console.log(`${x}的第${y} 位的二进制位${result}`)
}
```
做与运算 例如做判断x的第五位的二进制是1还是0，可以将x>>4 结果与1做与运算 判断最终的结果是1 还是0 ，如果结果为0 ，则第五位为0 否则为1
```js
const judje0_1=(x,y)=>{
  const result = x>>(y-1)&1 ===0?'0':'1'
  console.log(`${x}的第${y} 位的二进制位${result}`)
}
``` 

### 交换两个整数变量的值
思路：利用异或的性质实现。对于任何数x，都有x^x =0, x^0 = x， 同自己求异或为0，同0求异或为自己。 自反性：A^B^B = A^0=A,连续喝同一个因子做异或运算，最终结果为自己。如交换A、B的值，有：
- A = A ^ B
- B = A ^ B B = A ^ B ^ B = A
- A = A ^ B

```js
const SwapValue=(a,b)=>{
  console.log(a,b)
  a= a^b;
  b= a^b;
  a= a^b;
  console.log(a,b)
}
```

链接地址 https://cshihong.github.io/2018/12/31/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%A5%87%E5%B7%A7%E6%B7%AB%E6%8A%80/

 n & 1 如果n为偶数 结果为0 如果n 为奇数  结果为1
 有符号数是利用二进制最高位表示符号0代表正，1代表负， 无符号表示的最高位的0、1 代表正常的数而部署符号
 \ >>> 表示无符号右移 也叫逻辑右移 即若该数为正，则高位补0， 而若该数为负数，则右移后高位同样补0
 \ >> 表示右移，如果该数为正，则高位补0 若为负数 则高位补1 
 \ << 表示左移， 不分正负数 低位补0 
 \ >> 表示右移 


 ### 知识点
  int 32位 4个字节 一个字节8个位置
  无符号数 声明变量
  有符号数 (-3>>>0).toString(2)   11111111111111111111111111111101
  第一位表示正负数 
  浮点数 不可以使用位操作  正负数 小数位 科学计数法
  位元算 只能用于 [整数]

  num*2 => num<<1

问题 
  如何使用二进制判断最高位、最低位

#### 异或
  0^1 = 1  1^0 = 1 0^0 = 0 1^1 = 0
  交换两个数据
  a = a^b;
  b = b^a;
  a = a^b;
  a^b^c^b^a= c;
 
  

顺序
- 颠倒二进制位  不太懂 明天好好听
  - 判断掩码  2^n 执行速度特别快 
  - 先向左移动一位 保留原来的  判断某一位是0还是1 
  - (res << 1) + (n & 1) 判断末尾是0 还是1 
  - (res << 1) + (n & 1)


- 汉明距离 

- 4的幂
   
- 最大单词乘积
   找到最大值 双重遍历 找到最大值  Math.max
   字母-a  |

- 比特位计数 汉明权重 里面有多少个1 
  - 算的是一个区间
  - 二进制
  - 其实是用的动态规划
  
- 只出现一次的数字
  - 方法一 hashMap 