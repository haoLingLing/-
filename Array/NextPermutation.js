/**
  下一个排列
  实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典中下一个更大的排列
  如果不存在下一个更大的排列，则将数字重新排列成最小的排列 即升序排列
  必须原地修改，只允许使用额外常数空间
  以下是一些列子，输入位于左侧列，其响应的输入位于右侧列
 */


 // 1 判断为最大组合 是否为降序排列 然后变成 升序排列
 // 2 如果不是降序排列  则找到下一个更大的排列

 // nums.sort((a,b)=>b-a).join('') === nums.join('')   
 // 如果相等，则变成  nums.sort((a,b)=>a-b)
 // 如果不想等 则去判断下一个更大的数据  全排列
 // 找到当前数组中的最大值  Math.max.applay(this,nums)
 // 





 